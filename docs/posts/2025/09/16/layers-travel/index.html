<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>layers-travel - Tatva</title>
    <meta name="description" content="Interactive 3D visualization of how neural network embeddings evolve across layers">
    <meta name="google-site-verification" content="IVG1y4MVA_6MT0wsjk13ooZDQLWXxvYcPXQlmf83MLM" />
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
    
    <!-- Mermaid.js for diagram rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#ff6b6b',
                primaryTextColor: '#333',
                primaryBorderColor: '#ff6b6b',
                lineColor: '#666',
                sectionBkgColor: '#f8f9fa',
                altSectionBkgColor: '#e9ecef',
                gridColor: '#ddd',
                tertiaryColor: '#f1f3f4'
            }
        });
    </script>
</head>
<body>
    <!-- Scroll Progress Bar -->
    <div class="scroll-progress">
        <div class="scroll-progress-bar" id="scroll-progress-bar"></div>
    </div>
    
    <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="/">Tatva</a>
        
        <nav class="site-nav">
            <div class="trigger">
                <a class="page-link" href="/">Home</a>
                <!-- <a class="page-link" href="/about">About</a> -->
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
                    <span class="theme-icon theme-icon-light">üåô</span>
                    <span class="theme-icon theme-icon-dark">‚òÄÔ∏è</span>
                </button>
            </div>
        </nav>
    </div>
</header> 
    
    <main class="page-content">
        <div class="wrapper">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">layers-travel</h1>
        <p class="post-meta">
            <time datetime="{{ page.date | date_to_xmlschema }}">
                September 16, 2025
            </time>
            
        </p>
    </header>

    <div class="post-content">
        <h1>Interactive 3D visualization of how neural network embeddings evolve across layers</h1>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Layer-wise Embedding Evolution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        select, input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #plot {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .info {
            margin-bottom: 10px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D Layer-wise Embedding Evolution Visualizer</h1>
        
<pre><code>    &lt;div class=&quot;controls&quot;&gt;
        &lt;select id=&quot;datasetSelect&quot; style=&quot;display: none;&quot;&gt;
            &lt;option value=&quot;&quot;&gt;Select Dataset&lt;/option&gt;
        &lt;/select&gt;
        &lt;label&gt;
            Z-separation: 
            &lt;input type=&quot;range&quot; id=&quot;zSeparation&quot; min=&quot;1&quot; max=&quot;20&quot; value=&quot;5&quot; /&gt;
            &lt;span id=&quot;zValue&quot;&gt;5&lt;/span&gt;
        &lt;/label&gt;
        &lt;button id=&quot;loadData&quot;&gt;Load Data&lt;/button&gt;
        &lt;span id=&quot;loadStatus&quot;&gt;&lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div id=&quot;info&quot; class=&quot;info&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;plot&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    let currentData = null;
    const JSON_FILE_PATH = &#39;https://tatva.sumityadav.com.np/posts/2025/09/16/layers-travel/all_layerwise_embeddings.json&#39;;
    
    // Color palette for categories
    const colors = [
        &#39;#e41a1c&#39;, &#39;#377eb8&#39;, &#39;#4daf4a&#39;, &#39;#984ea3&#39;, 
        &#39;#ff7f00&#39;, &#39;#ffff33&#39;, &#39;#a65628&#39;, &#39;#f781bf&#39;
    ];

    document.getElementById(&#39;loadData&#39;).addEventListener(&#39;click&#39;, loadDataFromFile);
    document.getElementById(&#39;datasetSelect&#39;).addEventListener(&#39;change&#39;, updateVisualization);
    document.getElementById(&#39;zSeparation&#39;).addEventListener(&#39;input&#39;, function() {
        document.getElementById(&#39;zValue&#39;).textContent = this.value;
        updateVisualization();
    });

    // Load data automatically on page load
    window.addEventListener(&#39;load&#39;, loadDataFromFile);

    function loadDataFromFile() {
        const statusEl = document.getElementById(&#39;loadStatus&#39;);
        statusEl.textContent = &#39;Loading...&#39;;
        statusEl.style.color = &#39;orange&#39;;
        
        fetch(JSON_FILE_PATH)
            .then(response =&gt; {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data =&gt; {
                currentData = data;
                populateDatasetSelect();
                updateVisualization();
                statusEl.textContent = &#39;Data loaded successfully!&#39;;
                statusEl.style.color = &#39;green&#39;;
            })
            .catch(error =&gt; {
                console.error(&#39;Error loading JSON:&#39;, error);
                statusEl.textContent = `Error loading data: ${error.message}`;
                statusEl.style.color = &#39;red&#39;;
                
                // Show fallback message
                document.getElementById(&#39;plot&#39;).innerHTML = `
                    &lt;div style=&quot;display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 18px;&quot;&gt;
                        &lt;div style=&quot;text-align: center;&quot;&gt;
                            &lt;p&gt;‚ùå Could not load JSON file from: ${JSON_FILE_PATH}&lt;/p&gt;
                            &lt;p style=&quot;font-size: 14px; color: #999;&quot;&gt;
                                Make sure the file exists at the specified path and the browser has permission to access it.
                            &lt;/p&gt;
                            &lt;p style=&quot;font-size: 12px; color: #ccc;&quot;&gt;
                                Note: For security reasons, browsers may block local file access. 
                                Consider running a local web server or hosting the file.
                            &lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                `;
            });
    }

    function populateDatasetSelect() {
        const select = document.getElementById(&#39;datasetSelect&#39;);
        select.innerHTML = &#39;&lt;option value=&quot;&quot;&gt;Select Dataset&lt;/option&gt;&#39;;
        
        if (currentData) {
            // Check if data has multiple datasets
            const datasetNames = Object.keys(currentData);
            if (datasetNames.length &gt; 1) {
                datasetNames.forEach(name =&gt; {
                    const option = document.createElement(&#39;option&#39;);
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                });
                select.style.display = &#39;block&#39;;
                select.value = datasetNames[0]; // Select first dataset
            } else {
                select.style.display = &#39;none&#39;;
            }
        }
    }

    function getCurrentDataset() {
        if (!currentData) return null;
        
        const selectedDataset = document.getElementById(&#39;datasetSelect&#39;).value;
        
        if (selectedDataset &amp;&amp; currentData[selectedDataset]) {
            return currentData[selectedDataset];
        } else if (currentData.layers) {
            // Single dataset format
            return currentData;
        } else {
            // Multiple datasets, return first one
            const firstKey = Object.keys(currentData)[0];
            return currentData[firstKey];
        }
    }

    function updateVisualization() {
        const dataset = getCurrentDataset();
        if (!dataset) return;

        const zSeparation = parseInt(document.getElementById(&#39;zSeparation&#39;).value);
        
        // Update info
        const info = document.getElementById(&#39;info&#39;);
        info.style.display = &#39;block&#39;;
        info.innerHTML = `
            &lt;strong&gt;Dataset:&lt;/strong&gt; ${dataset.dataset_name || &#39;Unknown&#39;} | 
            &lt;strong&gt;Description:&lt;/strong&gt; ${dataset.description || &#39;N/A&#39;} | 
            &lt;strong&gt;Total Items:&lt;/strong&gt; ${dataset.total_items || &#39;N/A&#39;} | 
            &lt;strong&gt;Layers:&lt;/strong&gt; ${dataset.num_layers || Object.keys(dataset.layers).length}
        `;

        // Prepare data for plotting
        const traces = [];
        const categories = dataset.categories || [];
        const categoryColors = {};
        categories.forEach((cat, i) =&gt; {
            categoryColors[cat] = colors[i % colors.length];
        });

        // Create traces for each category
        categories.forEach(category =&gt; {
            const x = [], y = [], z = [], text = [], layer_info = [];
            
            Object.entries(dataset.layers).forEach(([layerStr, layerData]) =&gt; {
                const layerIdx = parseInt(layerStr);
                const zLevel = layerIdx * zSeparation;
                
                layerData.items.forEach(item =&gt; {
                    if (item.category === category) {
                        x.push(item.pca_coordinates.x);
                        y.push(item.pca_coordinates.y);
                        z.push(zLevel);
                        text.push(`${item.text}&lt;br&gt;Category: ${item.category}&lt;br&gt;Layer: ${layerIdx}`);
                        layer_info.push(layerIdx);
                    }
                });
            });

            if (x.length &gt; 0) {
                traces.push({
                    x: x,
                    y: y,
                    z: z,
                    text: text,
                    type: &#39;scatter3d&#39;,
                    mode: &#39;markers&#39;,
                    name: category,
                    marker: {
                        size: 6,
                        color: categoryColors[category],
                        opacity: 0.8,
                        line: {
                            color: &#39;black&#39;,
                            width: 0.5
                        }
                    },
                    hovertemplate: &#39;%{text}&lt;extra&gt;&lt;/extra&gt;&#39;
                });
            }
        });

        // Add trajectory lines for same text across layers
        const textTrajectories = {};
        Object.entries(dataset.layers).forEach(([layerStr, layerData]) =&gt; {
            const layerIdx = parseInt(layerStr);
            const zLevel = layerIdx * zSeparation;
            
            layerData.items.forEach(item =&gt; {
                if (!textTrajectories[item.text]) {
                    textTrajectories[item.text] = {
                        x: [], y: [], z: [], 
                        category: item.category
                    };
                }
                textTrajectories[item.text].x.push(item.pca_coordinates.x);
                textTrajectories[item.text].y.push(item.pca_coordinates.y);
                textTrajectories[item.text].z.push(zLevel);
            });
        });

        // Add trajectory lines
        Object.values(textTrajectories).forEach((traj, i) =&gt; {
            if (traj.x.length &gt; 1) {
                traces.push({
                    x: traj.x,
                    y: traj.y,
                    z: traj.z,
                    type: &#39;scatter3d&#39;,
                    mode: &#39;lines&#39;,
                    name: &#39;&#39;,
                    showlegend: false,
                    line: {
                        color: categoryColors[traj.category],
                        width: 2,
                        opacity: 0.3
                    },
                    hoverinfo: &#39;skip&#39;
                });
            }
        });

        const layout = {
            title: `3D Layer-wise Embedding Evolution: ${dataset.dataset_name || &#39;Dataset&#39;}`,
            scene: {
                xaxis: { title: &#39;PC1&#39; },
                yaxis: { title: &#39;PC2&#39; },
                zaxis: { title: &#39;Layer Index&#39; },
                camera: {
                    eye: { x: 1.5, y: 1.5, z: 1.5 }
                }
            },
            margin: { l: 0, r: 0, b: 0, t: 40 },
            legend: {
                x: 0,
                y: 1
            }
        };

        Plotly.newPlot(&#39;plot&#39;, traces, layout, {
            responsive: true,
            displayModeBar: true
        });
    }

    // Instructions for user
    if (!currentData) {
        document.getElementById(&#39;plot&#39;).innerHTML = `
            &lt;div style=&quot;display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 18px;&quot;&gt;
                &lt;div style=&quot;text-align: center;&quot;&gt;
                    &lt;p&gt;Loading data from: ${JSON_FILE_PATH}&lt;/p&gt;
                    &lt;p style=&quot;font-size: 14px; color: #999;&quot;&gt;
                        Click &quot;Load Data&quot; if the data doesn&#39;t load automatically
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        `;
    }
&lt;/script&gt;
</code></pre>
</body>

    </div>

    <footer class="post-footer">
        <p><a href="/">&larr; Back to all posts</a></p>
    </footer>
</article> 
        </div>
    </main>
    
    <footer class="site-footer">
    <div class="wrapper">
        <div class="footer-content">
            <p>&copy; 2025 Made with ‚ù§Ô∏è | All rights reserved to <a href="https://sumityadav.com.np" target="_blank">sumityadav.com.np</a></p>
            
                <p>Contact: <a href="mailto:rockerritesh4@gmail.com">rockerritesh4@gmail.com</a></p>
            
        </div>
    </div>
</footer> 
    
    <!-- Theme toggle functionality -->
    <script>
        (function() {
            // Get theme preference from localStorage or default to system preference
            const getThemePreference = () => {
                const stored = localStorage.getItem('theme-preference');
                if (stored) return stored;
                
                return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            };
            
            // Apply theme to document
            const applyTheme = (theme) => {
                const root = document.documentElement;
                root.classList.remove('light-theme', 'dark-theme');
                
                if (theme !== 'auto') {
                    root.classList.add(`${theme}-theme`);
                }
                
                // Update Mermaid theme if it exists
                if (window.mermaid) {
                    const mermaidTheme = theme === 'dark' || 
                        (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches) 
                        ? 'dark' : 'default';
                    
                    mermaid.initialize({ 
                        startOnLoad: true,
                        theme: mermaidTheme,
                        themeVariables: {
                            primaryColor: theme === 'dark' ? '#4da6ff' : '#ff6b6b',
                            primaryTextColor: theme === 'dark' ? '#e0e0e0' : '#333',
                            primaryBorderColor: theme === 'dark' ? '#4da6ff' : '#ff6b6b',
                            lineColor: theme === 'dark' ? '#a0a0a0' : '#666',
                            sectionBkgColor: theme === 'dark' ? '#2a2a2a' : '#f8f9fa',
                            altSectionBkgColor: theme === 'dark' ? '#333' : '#e9ecef',
                            gridColor: theme === 'dark' ? '#333' : '#ddd',
                            tertiaryColor: theme === 'dark' ? '#2a2a2a' : '#f1f3f4'
                        }
                    });
                    
                    // Re-render existing diagrams
                    document.querySelectorAll('.mermaid').forEach(el => {
                        if (el.getAttribute('data-processed')) {
                            el.removeAttribute('data-processed');
                            el.innerHTML = el.getAttribute('data-original') || el.innerHTML;
                        }
                    });
                    mermaid.init(undefined, '.mermaid');
                }
            };
            
            // Toggle theme function
            const toggleTheme = () => {
                const currentTheme = getThemePreference();
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                localStorage.setItem('theme-preference', newTheme);
                applyTheme(newTheme);
            };
            
            // Apply theme on page load
            document.addEventListener('DOMContentLoaded', () => {
                const theme = getThemePreference();
                applyTheme(theme);
                
                // Add click event to theme toggle button
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', toggleTheme);
                }
                
                // Store original mermaid content for re-rendering
                document.querySelectorAll('.mermaid').forEach(el => {
                    if (!el.getAttribute('data-original')) {
                        el.setAttribute('data-original', el.innerHTML);
                    }
                });
            });
            
            // Listen for system theme changes
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Only respond to system changes if user hasn't set a manual preference
                if (!localStorage.getItem('theme-preference')) {
                    applyTheme(e.matches ? 'dark' : 'light');
                }
            });
        })();
        
        // Scroll Progress Bar functionality
        (function() {
            const scrollProgressBar = document.getElementById('scroll-progress-bar');
            
            if (!scrollProgressBar) return;
            
            function updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                
                scrollProgressBar.style.height = Math.min(Math.max(scrollPercent, 0), 100) + '%';
            }
            
            // Update on scroll
            window.addEventListener('scroll', updateScrollProgress, { passive: true });
            
            // Update on resize (in case content changes)
            window.addEventListener('resize', updateScrollProgress, { passive: true });
            
            // Initial update
            updateScrollProgress();
        })();
    </script>
</body>
</html> 