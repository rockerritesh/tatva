<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>layers-travel - Tatva</title>
    <meta name="description" content="Interactive 3D visualization of how neural network embeddings evolve across layers">
    <meta name="google-site-verification" content="IVG1y4MVA_6MT0wsjk13ooZDQLWXxvYcPXQlmf83MLM" />
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css">
    
    <!-- Mermaid.js for diagram rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#ff6b6b',
                primaryTextColor: '#333',
                primaryBorderColor: '#ff6b6b',
                lineColor: '#666',
                sectionBkgColor: '#f8f9fa',
                altSectionBkgColor: '#e9ecef',
                gridColor: '#ddd',
                tertiaryColor: '#f1f3f4'
            }
        });
    </script>
</head>
<body>
    <!-- Scroll Progress Bar -->
    <div class="scroll-progress">
        <div class="scroll-progress-bar" id="scroll-progress-bar"></div>
    </div>
    
    <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="/">Tatva</a>
        
        <nav class="site-nav">
            <div class="trigger">
                <a class="page-link" href="/">Home</a>
                <!-- <a class="page-link" href="/about">About</a> -->
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
                    <span class="theme-icon theme-icon-light">üåô</span>
                    <span class="theme-icon theme-icon-dark">‚òÄÔ∏è</span>
                </button>
            </div>
        </nav>
    </div>
</header> 
    
    <main class="page-content">
        <div class="wrapper">
            
<article class="post">
    <header class="post-header">
        <h1 class="post-title">layers-travel</h1>
        <p class="post-meta">
            <time datetime="{{ page.date | date_to_xmlschema }}">
                September 16, 2025
            </time>
            
        </p>
    </header>

    <div class="post-content">
        <h1>3D Layer-wise Embedding Evolution</h1>
<p>This visualization shows how neural network embeddings evolve across different layers. Each point represents a text sample positioned in 2D PCA space, with the Z-axis representing the layer index. Trajectory lines connect the same text samples across layers, revealing how the embedding space transforms through the network.</p>
<h2>Features</h2>
<ul>
<li><strong>Interactive 3D Plot</strong>: Rotate, zoom, and pan to explore the embedding space</li>
<li><strong>Layer Evolution</strong>: See how embeddings change from input to output layers</li>
<li><strong>Category Visualization</strong>: Different colors for different categories with legend</li>
<li><strong>Trajectory Tracking</strong>: Lines show how individual samples move through embedding space</li>
<li><strong>Adjustable Z-separation</strong>: Control the spacing between layers</li>
</ul>
<h2>Datasets</h2>
<p>The visualization includes three datasets:</p>
<ul>
<li><strong>Sentiment Analysis</strong>: Positive, negative, and neutral sentiment classifications</li>
<li><strong>Academic Subjects</strong>: Science, mathematics, and literature texts</li>
<li><strong>Scientific Domains</strong>: Astronomy, biology, and physics research topics</li>
</ul>
<div id="embedding-visualization">
<style>
body {
    font-family: Arial, sans-serif;
}
.viz-container {
    max-width: 100%;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin: 20px 0;
}
.controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
}
.controls select, .controls input[type="range"] {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.controls button {
    padding: 8px 16px;
    background: #007cba;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
.controls button:hover {
    background: #005a87;
}
#plot {
    width: 100%;
    height: 600px;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.info {
    margin-bottom: 10px;
    padding: 10px;
    background: #e8f4f8;
    border-radius: 4px;
    font-size: 14px;
}
#loadStatus {
    margin-left: 10px;
    font-weight: bold;
}
.demo-note {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 4px;
    padding: 15px;
    margin-bottom: 20px;
    color: #856404;
}
</style>

<div class="viz-container">
    <div class="demo-note">
        <strong>Loading...</strong> Attempting to load embedding data from JSON file.
    </div>
    
<pre><code>&lt;div class=&quot;controls&quot;&gt;
    &lt;select id=&quot;datasetSelect&quot; style=&quot;display: none;&quot;&gt;
        &lt;option value=&quot;&quot;&gt;Select Dataset&lt;/option&gt;
    &lt;/select&gt;
    &lt;label&gt;
        Z-separation: 
        &lt;input type=&quot;range&quot; id=&quot;zSeparation&quot; min=&quot;1&quot; max=&quot;20&quot; value=&quot;5&quot; /&gt;
        &lt;span id=&quot;zValue&quot;&gt;5&lt;/span&gt;
    &lt;/label&gt;
    &lt;button id=&quot;loadData&quot;&gt;Load JSON Data&lt;/button&gt;
    &lt;button id=&quot;generateData&quot; style=&quot;display: none;&quot;&gt;Generate Synthetic Data&lt;/button&gt;
    &lt;span id=&quot;loadStatus&quot;&gt;Initializing...&lt;/span&gt;
&lt;/div&gt;

&lt;div id=&quot;info&quot; class=&quot;info&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;plot&quot;&gt;&lt;/div&gt;
</code></pre>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
<script>
    let currentData = null;
    
    // Color palette for categories
    const colors = [
        '#e41a1c', '#377eb8', '#4daf4a', '#984ea3', 
        '#ff7f00', '#ffff33', '#a65628', '#f781bf'
    ];

    // Dataset definitions
    const datasetConfigs = {
        sentiment: {
            dataset_name: 'Sentiment Analysis',
            description: 'Text samples with positive, negative, and neutral sentiments',
            categories: ['Positive', 'Negative', 'Neutral'],
            samples: [
                'This movie is absolutely fantastic!',
                'I love sunny days and fresh air',
                'What a wonderful surprise this was',
                'This is the worst experience ever',
                'I hate waiting in long lines',
                'Terrible service and bad food',
                'The weather is okay today',
                'This product works as expected',
                'Nothing special about this place'
            ]
        },
        academic: {
            dataset_name: 'Academic Subjects',
            description: 'Academic texts from science, mathematics, and literature',
            categories: ['Science', 'Mathematics', 'Literature'],
            samples: [
                'Photosynthesis converts light energy into chemical energy',
                'DNA replication occurs during the S phase',
                'Newton\'s laws describe the motion of objects',
                'The derivative of x squared is 2x',
                'Integration is the reverse of differentiation',
                'Prime numbers have no divisors except 1 and themselves',
                'Shakespeare wrote many famous tragedies',
                'Poetry uses rhythm and metaphor effectively',
                'The hero\'s journey is a common narrative structure'
            ]
        },
        scientific: {
            dataset_name: 'Scientific Domains',
            description: 'Research topics from astronomy, biology, and physics',
            categories: ['Astronomy', 'Biology', 'Physics'],
            samples: [
                'Black holes have intense gravitational fields',
                'Stars form from collapsing gas clouds',
                'Galaxies contain billions of stars',
                'Cells are the basic unit of life',
                'Evolution drives species adaptation',
                'DNA carries genetic information',
                'Quantum mechanics describes subatomic behavior',
                'Energy and matter are equivalent',
                'Forces cause changes in motion'
            ]
        }
    };

    const JSON_FILE_PATH = 'https://tatva.sumityadav.com.np/posts/2025/09/16/layers-travel/all_layerwise_embeddings.json';

    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Add event listeners
        document.getElementById('loadData').addEventListener('click', loadDataFromFile);
        document.getElementById('generateData').addEventListener('click', generateSyntheticData);
        document.getElementById('datasetSelect').addEventListener('change', updateVisualization);
        document.getElementById('zSeparation').addEventListener('input', function() {
            const zValue = document.getElementById('zValue');
            if (zValue) {
                zValue.textContent = this.value;
                updateVisualization();
            }
        });

        // Try to load JSON data automatically on startup
        loadDataFromFile();
    });

    function loadDataFromFile() {
        const statusEl = document.getElementById('loadStatus');
        if (statusEl) {
            statusEl.textContent = 'Loading JSON data...';
            statusEl.style.color = 'orange';
        }
        
        fetch(JSON_FILE_PATH)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                currentData = data;
                populateDatasetSelect();
                updateVisualization();
                if (statusEl) {
                    statusEl.textContent = 'JSON data loaded successfully!';
                    statusEl.style.color = 'green';
                }
                
                // Update the demo note to indicate real data is loaded
                const demoNote = document.querySelector('.demo-note');
                if (demoNote) {
                    demoNote.innerHTML = '<strong>Real Data Loaded:</strong> Successfully loaded embedding data from JSON file.';
                    demoNote.style.background = '#d4edda';
                    demoNote.style.borderColor = '#c3e6cb';
                    demoNote.style.color = '#155724';
                }
                
                // Hide synthetic data button, show dataset controls
                const generateBtn = document.getElementById('generateData');
                const loadBtn = document.getElementById('loadData');
                if (generateBtn) generateBtn.style.display = 'none';
                if (loadBtn) loadBtn.style.display = 'none';
            })
            .catch(error => {
                console.error('Error loading JSON:', error);
                if (statusEl) {
                    statusEl.textContent = `JSON load failed, using synthetic data`;
                    statusEl.style.color = 'orange';
                }
                
                // Update demo note to explain fallback
                const demoNote = document.querySelector('.demo-note');
                if (demoNote) {
                    demoNote.innerHTML = `
                        <strong>Fallback Mode:</strong> Could not load JSON from: <br>
                        <code>${JSON_FILE_PATH}</code><br>
                        <strong>Error:</strong> ${error.message}<br>
                        <em>Using synthetic data to demonstrate the visualization.</em>
                    `;
                    demoNote.style.background = '#fff3cd';
                    demoNote.style.borderColor = '#ffeaa7';
                    demoNote.style.color = '#856404';
                }
                
                // Show synthetic data controls, hide JSON load button
                const generateBtn = document.getElementById('generateData');
                const loadBtn = document.getElementById('loadData');
                const datasetSelect = document.getElementById('datasetSelect');
                
                if (generateBtn) generateBtn.style.display = 'inline-block';
                if (loadBtn) loadBtn.textContent = 'Retry JSON Load';
                if (datasetSelect) {
                    datasetSelect.innerHTML = `
                        <option value="sentiment">Sentiment Analysis</option>
                        <option value="academic">Academic Subjects</option>
                        <option value="scientific">Scientific Domains</option>
                    `;
                    datasetSelect.style.display = 'inline-block';
                    datasetSelect.value = 'sentiment';
                }
                
                // Fallback to synthetic data
                generateSyntheticData();
            });
    }

    function populateDatasetSelect() {
        const select = document.getElementById('datasetSelect');
        if (!select) return;
        
        // Clear existing options
        select.innerHTML = '<option value="">Select Dataset</option>';
        
        if (currentData) {
            // Check if data has multiple datasets
            const datasetNames = Object.keys(currentData);
            if (datasetNames.length > 1 && !currentData.layers) {
                // Multiple datasets format
                select.innerHTML = '<option value="">Select Dataset</option>';
                datasetNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    select.appendChild(option);
                });
                select.value = datasetNames[0]; // Select first dataset
                select.style.display = 'inline-block';
            } else {
                // Single dataset format - hide the select
                select.style.display = 'none';
            }
        }
    }

    function getCurrentDataset() {
        if (!currentData) return null;
        
        const selectedDataset = document.getElementById('datasetSelect').value;
        
        if (selectedDataset && currentData[selectedDataset]) {
            return currentData[selectedDataset];
        } else if (currentData.layers) {
            // Single dataset format
            return currentData;
        } else {
            // Multiple datasets, return first one
            const firstKey = Object.keys(currentData)[0];
            return currentData[firstKey];
        }
    }

    function generateSyntheticData() {
        const statusEl = document.getElementById('loadStatus');
        if (statusEl) {
            statusEl.textContent = 'Generating...';
            statusEl.style.color = 'orange';
        }

        const selectedDataset = document.getElementById('datasetSelect').value;
        const config = datasetConfigs[selectedDataset];
        
        // Generate synthetic embedding data
        const numLayers = 6;
        const layers = {};
        
        for (let layer = 0; layer < numLayers; layer++) {
            const items = [];
            
            config.samples.forEach((text, textIdx) => {
                const categoryIdx = textIdx % config.categories.length;
                const category = config.categories[categoryIdx];
                
                // Create realistic embedding evolution
                // Start with random positions, then gradually cluster by category
                const clusterProgress = layer / (numLayers - 1);
                const randomComponent = 1 - clusterProgress;
                const clusterComponent = clusterProgress;
                
                // Base cluster centers for each category
                const clusterCenters = {
                    [config.categories[0]]: { x: -2, y: 1 },
                    [config.categories[1]]: { x: 2, y: -1 },
                    [config.categories[2]]: { x: 0, y: 2 }
                };
                
                const center = clusterCenters[category] || { x: 0, y: 0 };
                
                // Add some consistent individual variation
                const individualSeed = textIdx * 1234.5;
                const individualX = Math.sin(individualSeed) * 0.5;
                const individualY = Math.cos(individualSeed) * 0.5;
                
                const x = (Math.random() - 0.5) * 4 * randomComponent + 
                         center.x * clusterComponent + individualX;
                const y = (Math.random() - 0.5) * 4 * randomComponent + 
                         center.y * clusterComponent + individualY;
                
                items.push({
                    text: text,
                    category: category,
                    pca_coordinates: { x: x, y: y }
                });
            });
            
            layers[layer] = { items: items };
        }
        
        currentData = {
            dataset_name: config.dataset_name,
            description: config.description,
            total_items: config.samples.length,
            num_layers: numLayers,
            categories: config.categories,
            layers: layers
        };
        
        updateVisualization();
        
        if (statusEl) {
            statusEl.textContent = 'Data generated successfully!';
            statusEl.style.color = 'green';
        }
    }

    function updateVisualization() {
        const dataset = getCurrentDataset();
        if (!dataset) return;

        const zSeparation = parseInt(document.getElementById('zSeparation').value) || 5;
        
        // Update info - check if element exists first
        const infoEl = document.getElementById('info');
        if (infoEl) {
            infoEl.style.display = 'block';
            infoEl.innerHTML = `
                <strong>Dataset:</strong> ${dataset.dataset_name || 'Unknown'} | 
                <strong>Description:</strong> ${dataset.description || 'N/A'} | 
                <strong>Total Items:</strong> ${dataset.total_items || 'N/A'} | 
                <strong>Layers:</strong> ${dataset.num_layers || Object.keys(dataset.layers).length}
            `;
        }

        // Prepare data for plotting
        const traces = [];
        const categories = dataset.categories || [];
        const categoryColors = {};
        categories.forEach((cat, i) => {
            categoryColors[cat] = colors[i % colors.length];
        });

        // Create traces for each category
        categories.forEach(category => {
            const x = [], y = [], z = [], text = [], layer_info = [];
            
            Object.entries(dataset.layers).forEach(([layerStr, layerData]) => {
                const layerIdx = parseInt(layerStr);
                const zLevel = layerIdx * zSeparation;
                
                layerData.items.forEach(item => {
                    if (item.category === category) {
                        x.push(item.pca_coordinates.x);
                        y.push(item.pca_coordinates.y);
                        z.push(zLevel);
                        text.push(`${item.text}<br>Category: ${item.category}<br>Layer: ${layerIdx}`);
                        layer_info.push(layerIdx);
                    }
                });
            });

            if (x.length > 0) {
                traces.push({
                    x: x,
                    y: y,
                    z: z,
                    text: text,
                    type: 'scatter3d',
                    mode: 'markers',
                    name: category,
                    marker: {
                        size: 8,
                        color: categoryColors[category],
                        opacity: 0.8,
                        line: {
                            color: 'black',
                            width: 0.5
                        }
                    },
                    hovertemplate: '%{text}<extra></extra>'
                });
            }
        });

        // Add trajectory lines for same text across layers
        const textTrajectories = {};
        Object.entries(dataset.layers).forEach(([layerStr, layerData]) => {
            const layerIdx = parseInt(layerStr);
            const zLevel = layerIdx * zSeparation;
            
            layerData.items.forEach(item => {
                if (!textTrajectories[item.text]) {
                    textTrajectories[item.text] = {
                        x: [], y: [], z: [], 
                        category: item.category
                    };
                }
                textTrajectories[item.text].x.push(item.pca_coordinates.x);
                textTrajectories[item.text].y.push(item.pca_coordinates.y);
                textTrajectories[item.text].z.push(zLevel);
            });
        });

        // Add trajectory lines
        Object.values(textTrajectories).forEach((traj, i) => {
            if (traj.x.length > 1) {
                traces.push({
                    x: traj.x,
                    y: traj.y,
                    z: traj.z,
                    type: 'scatter3d',
                    mode: 'lines',
                    name: '',
                    showlegend: false,
                    line: {
                        color: categoryColors[traj.category],
                        width: 3,
                        opacity: 0.4
                    },
                    hoverinfo: 'skip'
                });
            }
        });

        const layout = {
            title: {
                text: `3D Layer-wise Embedding Evolution: ${dataset.dataset_name || 'Dataset'}`,
                font: { size: 16 }
            },
            scene: {
                xaxis: { title: 'PC1' },
                yaxis: { title: 'PC2' },
                zaxis: { title: 'Layer Index' },
                camera: {
                    eye: { x: 1.5, y: 1.5, z: 1.5 }
                }
            },
            margin: { l: 0, r: 0, b: 0, t: 60 },
            legend: {
                x: 0,
                y: 1
            }
        };

        const plotEl = document.getElementById('plot');
        if (plotEl) {
            Plotly.newPlot('plot', traces, layout, {
                responsive: true,
                displayModeBar: true
            });
        }
    }
</script>
</div>

<h2>How to Use</h2>
<ol>
<li>Select a dataset from the dropdown menu</li>
<li>Click &quot;Generate New Data&quot; to create new synthetic embeddings</li>
<li>Adjust the Z-separation slider to change layer spacing</li>
<li>Click and drag to rotate the 3D plot</li>
<li>Use mouse wheel to zoom in/out</li>
<li>Hover over points to see detailed information</li>
</ol>
<h2>Technical Details</h2>
<p>The visualization uses:</p>
<ul>
<li><strong>Plotly.js</strong> for 3D rendering</li>
<li><strong>Synthetic PCA coordinates</strong> for 2D positioning at each layer</li>
<li><strong>Layer index</strong> as the Z-axis dimension</li>
<li><strong>Trajectory lines</strong> to show evolution paths</li>
<li><strong>Color coding</strong> by semantic categories</li>
</ul>
<h2>Interpretation</h2>
<ul>
<li>Points closer together represent similar embeddings</li>
<li>Trajectory lines show how individual samples move through the embedding space</li>
<li>Layer progression (Z-axis) reveals how the network transforms representations</li>
<li>Category clustering indicates semantic organization at different layers</li>
<li>Early layers show more random distribution, later layers show clearer category separation</li>
</ul>
<h2>Key Observations</h2>
<ul>
<li><strong>Layer 0-1</strong>: Embeddings start relatively scattered with little semantic structure</li>
<li><strong>Layer 2-3</strong>: Gradual emergence of category-based clustering</li>
<li><strong>Layer 4-5</strong>: Clear separation between different semantic categories</li>
<li><strong>Trajectory lines</strong>: Show smooth transitions rather than abrupt jumps</li>
</ul>
<hr>
<p><em>Note: This demo uses synthetic data to illustrate the concept. In a real implementation, you would replace the synthetic data generation with actual neural network embeddings from your model.</em></p>

    </div>

    <footer class="post-footer">
        <p><a href="/">&larr; Back to all posts</a></p>
    </footer>
</article> 
        </div>
    </main>
    
    <footer class="site-footer">
    <div class="wrapper">
        <div class="footer-content">
            <p>&copy; 2025 Made with ‚ù§Ô∏è | All rights reserved to <a href="https://sumityadav.com.np" target="_blank">sumityadav.com.np</a></p>
            
                <p>Contact: <a href="mailto:rockerritesh4@gmail.com">rockerritesh4@gmail.com</a></p>
            
        </div>
    </div>
</footer> 
    
    <!-- Theme toggle functionality -->
    <script>
        (function() {
            // Get theme preference from localStorage or default to system preference
            const getThemePreference = () => {
                const stored = localStorage.getItem('theme-preference');
                if (stored) return stored;
                
                return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            };
            
            // Apply theme to document
            const applyTheme = (theme) => {
                const root = document.documentElement;
                root.classList.remove('light-theme', 'dark-theme');
                
                if (theme !== 'auto') {
                    root.classList.add(`${theme}-theme`);
                }
                
                // Update Mermaid theme if it exists
                if (window.mermaid) {
                    const mermaidTheme = theme === 'dark' || 
                        (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches) 
                        ? 'dark' : 'default';
                    
                    mermaid.initialize({ 
                        startOnLoad: true,
                        theme: mermaidTheme,
                        themeVariables: {
                            primaryColor: theme === 'dark' ? '#4da6ff' : '#ff6b6b',
                            primaryTextColor: theme === 'dark' ? '#e0e0e0' : '#333',
                            primaryBorderColor: theme === 'dark' ? '#4da6ff' : '#ff6b6b',
                            lineColor: theme === 'dark' ? '#a0a0a0' : '#666',
                            sectionBkgColor: theme === 'dark' ? '#2a2a2a' : '#f8f9fa',
                            altSectionBkgColor: theme === 'dark' ? '#333' : '#e9ecef',
                            gridColor: theme === 'dark' ? '#333' : '#ddd',
                            tertiaryColor: theme === 'dark' ? '#2a2a2a' : '#f1f3f4'
                        }
                    });
                    
                    // Re-render existing diagrams
                    document.querySelectorAll('.mermaid').forEach(el => {
                        if (el.getAttribute('data-processed')) {
                            el.removeAttribute('data-processed');
                            el.innerHTML = el.getAttribute('data-original') || el.innerHTML;
                        }
                    });
                    mermaid.init(undefined, '.mermaid');
                }
            };
            
            // Toggle theme function
            const toggleTheme = () => {
                const currentTheme = getThemePreference();
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                localStorage.setItem('theme-preference', newTheme);
                applyTheme(newTheme);
            };
            
            // Apply theme on page load
            document.addEventListener('DOMContentLoaded', () => {
                const theme = getThemePreference();
                applyTheme(theme);
                
                // Add click event to theme toggle button
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', toggleTheme);
                }
                
                // Store original mermaid content for re-rendering
                document.querySelectorAll('.mermaid').forEach(el => {
                    if (!el.getAttribute('data-original')) {
                        el.setAttribute('data-original', el.innerHTML);
                    }
                });
            });
            
            // Listen for system theme changes
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Only respond to system changes if user hasn't set a manual preference
                if (!localStorage.getItem('theme-preference')) {
                    applyTheme(e.matches ? 'dark' : 'light');
                }
            });
        })();
        
        // Scroll Progress Bar functionality
        (function() {
            const scrollProgressBar = document.getElementById('scroll-progress-bar');
            
            if (!scrollProgressBar) return;
            
            function updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                
                scrollProgressBar.style.height = Math.min(Math.max(scrollPercent, 0), 100) + '%';
            }
            
            // Update on scroll
            window.addEventListener('scroll', updateScrollProgress, { passive: true });
            
            // Update on resize (in case content changes)
            window.addEventListener('resize', updateScrollProgress, { passive: true });
            
            // Initial update
            updateScrollProgress();
        })();
    </script>
</body>
</html> 