
<article class="post">
    <header class="post-header">
        <h1 class="post-title">AgentsAI</h1>
        <p class="post-meta">
            <time datetime="{{ page.date | date_to_xmlschema }}">
                July 1, 2025
            </time>
            
        </p>
    </header>

    <div class="post-content">
        <h1>ğŸ¤– Building an Intelligent Multi-Agent System: How AI Agents Collaborate to Solve Complex Tasks</h1>
<p><em>Ever wondered how to create a system where AI agents automatically choose the right tools for any task? Welcome to the future of intelligent automation! ğŸš€</em></p>
<hr>
<h2>ğŸŒŸ Introduction: The Dawn of Intelligent Agent Orchestration</h2>
<p>In the rapidly evolving landscape of AI, we&#39;re witnessing a paradigm shift from single-purpose tools to intelligent, collaborative agent systems. Today, I&#39;m excited to share the technical deep-dive into <strong>agents.ai</strong> - a sophisticated multi-agent system that automatically selects the best agent and tool sequence to handle user queries using semantic similarity and advanced orchestration techniques.</p>
<p>ğŸ”— <strong><a href="https://github.com/rockerritesh/agents.ai">Explore the full implementation on GitHub</a></strong></p>
<h2>ğŸ¯ What Makes This System Revolutionary?</h2>
<p>Traditional AI applications follow a rigid, predetermined flow. But what if your system could think, analyze, and automatically determine the best approach for each unique request? That&#39;s exactly what this multi-agent system accomplishes:</p>
<ul>
<li><strong>ğŸ§  Intelligent Agent Selection</strong>: Uses cosine similarity with embeddings to find the most relevant agent</li>
<li><strong>ğŸ”„ Dynamic Tool Orchestration</strong>: Automatically determines optimal tool sequences</li>
<li><strong>ğŸ’­ Context-Aware Processing</strong>: Maintains conversation history for coherent multi-turn interactions</li>
<li><strong>ğŸ¨ Specialized Expertise</strong>: Five distinct agents, each mastered in specific domains</li>
</ul>
<h2>ğŸ—ï¸ System Architecture: The Technical Foundation</h2>
<h3>Core Workflow Visualization</h3>
<p>The system follows an elegant flow that mimics human problem-solving approaches:</p>
<pre><code class="language-mermaid">flowchart TD
    A[&quot;ğŸ§‘â€ğŸ’» User Query&quot;] --&gt; B[&quot;ğŸ“Š Query Embedding&lt;br/&gt;OpenAI text-embedding-3-large&quot;]
    B --&gt; C[&quot;ğŸ¯ Agent Selection&lt;br/&gt;Cosine Similarity &gt; 0.5&quot;]
    C --&gt; D{&quot;ğŸ¤” Agent Found?&quot;}
    D --&gt;|No| E[&quot;ğŸ’¬ General Chat Response&quot;]
    D --&gt;|Yes| F[&quot;ğŸ› ï¸ Tool Sequence Planning&quot;]
    F --&gt; G[&quot;âš™ï¸ Tool Execution Loop&quot;]
    G --&gt; H[&quot;ğŸ“ Context Gathering&quot;]
    H --&gt; I[&quot;ğŸ”„ Tool Function Call&quot;]
    I --&gt; J[&quot;ğŸ’¾ Store Results&quot;]
    J --&gt; K{&quot;ğŸ”„ More Tools?&quot;}
    K --&gt;|Yes| H
    K --&gt;|No| L[&quot;ğŸ“‹ Results Summary&quot;]
    L --&gt; M[&quot;âœ… Response to User&quot;]
    
    style A fill:#e1f5fe
    style C fill:#f3e5f5
    style F fill:#e8f5e8
    style I fill:#fff3e0
    style M fill:#e8f5e8
</code></pre>
<h3>Agent Ecosystem Overview</h3>
<pre><code class="language-mermaid">graph TB
    subgraph &quot;ğŸ¤– Agent Ecosystem&quot;
        A1[&quot;ğŸ“Š CSVDataAgent&lt;br/&gt;DataframeLoader&lt;br/&gt;AdvanceCSVQuery&quot;]
        A2[&quot;ğŸ˜€ EmojiWriter&lt;br/&gt;EmojiTranslator&lt;br/&gt;EmojiMixer&quot;]
        A3[&quot;ğŸ“ TextSummarizer&lt;br/&gt;KeypointExtractor&lt;br/&gt;ContentExpander&quot;]
        A4[&quot;ğŸ“„ PDFContentWriter&lt;br/&gt;TextExtractor&lt;br/&gt;ContentReformatter&quot;]
        A5[&quot;ğŸŒ TranslatorAgent&lt;br/&gt;MultilingualTranslator&lt;br/&gt;StylePreserver&quot;]
    end
    
    subgraph &quot;ğŸ”§ Core System&quot;
        B1[&quot;ğŸ¯ Agent Selection Engine&quot;]
        B2[&quot;ğŸ› ï¸ Tool Orchestrator&quot;]
        B3[&quot;ğŸ’¬ Conversation Manager&quot;]
        B4[&quot;ğŸ“Š Embedding Generator&quot;]
    end
    
    subgraph &quot;ğŸ”Œ Integration Layer&quot;
        C1[&quot;ğŸ§  OpenAI GPT-4o&quot;]
        C2[&quot;ğŸ”¤ OpenAI Embeddings&quot;]
        C3[&quot;ğŸ“‚ File System&quot;]
        C4[&quot;ğŸ’¾ Conversation History&quot;]
    end
    
    B1 --&gt; A1
    B1 --&gt; A2
    B1 --&gt; A3
    B1 --&gt; A4
    B1 --&gt; A5
    
    B2 --&gt; B1
    B3 --&gt; B2
    B4 --&gt; B1
    
    B4 --&gt; C2
    B2 --&gt; C1
    B3 --&gt; C4
    A1 --&gt; C3
    A4 --&gt; C3
    
    style A1 fill:#e3f2fd
    style A2 fill:#fff3e0
    style A3 fill:#e8f5e8
    style A4 fill:#fce4ec
    style A5 fill:#f3e5f5
</code></pre>
<h2>ğŸ”¬ Technical Deep Dive: How It All Works</h2>
<h3>1. ğŸ¯ Semantic Agent Selection</h3>
<p>The heart of the system lies in its intelligent agent selection mechanism. Here&#39;s how it works:</p>
<pre><code class="language-python">def find_relevant_agents(query, agents_list, top_n=3):
    &quot;&quot;&quot;Find the most relevant agents based on semantic similarity&quot;&quot;&quot;
    query_embedding = get_embedding(query)
    sim_scores = []
    
    for agent in agents_list:
        similarity = CosineSimilarityCalculator.calculate_similarity(
            embedding1=query_embedding, 
            embedding2=agent.embedding
        )
        sim_scores.append({&#39;agent&#39;: agent, &#39;similarity&#39;: similarity})
    
    # Sort by similarity score
    sim_scores.sort(key=lambda x: x[&#39;similarity&#39;], reverse=True)
    
    # Threshold filtering: only agents with similarity &gt; 0.5
    if sim_scores[0][&#39;similarity&#39;] &lt; 0.5:
        return []  # Fall back to general chat
    
    return sim_scores[:top_n]
</code></pre>
<p><strong>Key Innovation</strong>: The system uses OpenAI&#39;s <code>text-embedding-3-large</code> model to create vector representations of both user queries and agent descriptions, then applies cosine similarity to find the best match.</p>
<h3>2. ğŸ› ï¸ Dynamic Tool Sequence Planning</h3>
<p>Once an agent is selected, the system dynamically determines the optimal tool sequence:</p>
<pre><code class="language-python">def determine_tool_sequence(agent, query):
    &quot;&quot;&quot;Determine the best sequence of tools for the task&quot;&quot;&quot;
    context_summary = &quot;\n\nHistory&quot; + str(history)
    
    message = [
        {
            &quot;role&quot;: &quot;system&quot;,
            &quot;content&quot;: DETERMINE_TOOLS.format(agent, context_summary)
        },
        {
            &quot;role&quot;: &quot;user&quot;, 
            &quot;content&quot;: query
        }
    ]
    
    tools_order = get_reply(message, ToolsSeqFinder)
    return tools_order.tools_name_in_seq
</code></pre>
<h3>3. ğŸ”„ Execution Flow Sequence</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant U as ğŸ§‘â€ğŸ’» User
    participant S as ğŸ¯ System
    participant E as ğŸ”¤ Embedding API
    participant A as ğŸ¤– Selected Agent
    participant T as ğŸ› ï¸ Tools
    participant L as ğŸ§  LLM API
    participant H as ğŸ’¾ History
    
    U-&gt;&gt;S: Submit Query
    S-&gt;&gt;E: Generate Query Embedding
    E--&gt;&gt;S: Return Embedding Vector
    S-&gt;&gt;S: Calculate Cosine Similarity
    S-&gt;&gt;A: Select Best Agent (&gt;0.5 threshold)
    A-&gt;&gt;L: Determine Tool Sequence
    L--&gt;&gt;A: Return Tool Order
    
    loop For Each Tool
        A-&gt;&gt;T: Gather Tool Inputs
        A-&gt;&gt;L: Get Missing Information
        L--&gt;&gt;A: Provide Inputs
        A-&gt;&gt;T: Execute Tool Function
        T--&gt;&gt;A: Return Results
        A-&gt;&gt;H: Store Context
    end
    
    A-&gt;&gt;L: Generate Final Summary
    L--&gt;&gt;A: Formatted Response
    A--&gt;&gt;U: Deliver Results
    
    Note over S,H: Maintains conversation&lt;br/&gt;context throughout
</code></pre>
<h2>ğŸ¤– Meet the Agent Squad: Specialized AI Workers</h2>
<h3>1. ğŸ“Š <strong>CSVDataAgent</strong> - The Data Scientist</h3>
<p><strong>Specialty</strong>: CSV data processing and analysis</p>
<pre><code class="language-yaml">tools:
  - DataframeLoader: Loads CSV/Excel files into pandas DataFrames
  - AdvanceCSVQuery: Performs complex queries and filtering
</code></pre>
<p><strong>Example Query</strong>: <em>&quot;Load earthquake.csv and show me the top 10 earthquakes by magnitude&quot;</em></p>
<h3>2. ğŸ˜€ <strong>EmojiWriter</strong> - The Creative Communicator</h3>
<p><strong>Specialty</strong>: Emoji content creation and translation</p>
<pre><code class="language-yaml">tools:
  - EmojiTranslator: Converts text to relevant emojis
  - EmojiMixer: Creates custom emoji combinations
</code></pre>
<p><strong>Example Query</strong>: <em>&quot;Convert &#39;I love sunny days at the beach&#39; to emojis&quot;</em></p>
<h3>3. ğŸ“ <strong>TextSummarizer</strong> - The Content Analyst</h3>
<p><strong>Specialty</strong>: Text analysis and content expansion</p>
<pre><code class="language-yaml">tools:
  - KeypointExtractor: Identifies main ideas from text
  - ContentExpander: Expands bullet points to full paragraphs
</code></pre>
<p><strong>Example Query</strong>: <em>&quot;Extract key points from this article and expand them&quot;</em></p>
<h3>4. ğŸ“„ <strong>PDFContentWriter</strong> - The Document Processor</h3>
<p><strong>Specialty</strong>: PDF processing and content reformatting</p>
<pre><code class="language-yaml">tools:
  - TextExtractor: Extracts text from PDF files
  - ContentReformatter: Reformats content into various types
</code></pre>
<p><strong>Example Query</strong>: <em>&quot;Extract text from resume.pdf and reformat as LinkedIn summary&quot;</em></p>
<h3>5. ğŸŒ <strong>TranslatorAgent</strong> - The Linguistic Expert</h3>
<p><strong>Specialty</strong>: Multilingual translation with style preservation</p>
<pre><code class="language-yaml">tools:
  - MultilingualTranslator: Translates between languages
  - StylePreserver: Maintains writing style during translation
</code></pre>
<p><strong>Example Query</strong>: <em>&quot;Translate this to Spanish while keeping the formal tone&quot;</em></p>
<h2>âš¡ Technical Implementation Highlights</h2>
<h3>Embedding-Based Intelligence</h3>
<p>The system leverages OpenAI&#39;s advanced embedding model for semantic understanding:</p>
<pre><code class="language-python">def get_embedding(text: str) -&gt; np.ndarray:
    &quot;&quot;&quot;Generate embeddings using OpenAI&#39;s text-embedding-3-large&quot;&quot;&quot;
    response = client.embeddings.create(
        model=&quot;text-embedding-3-large&quot;,
        input=text
    )
    return np.array(response.data[0].embedding)
</code></pre>
<h3>Pydantic-Powered Type Safety</h3>
<p>Every tool input/output is strictly typed using Pydantic models:</p>
<pre><code class="language-python">class ToolsSeqFinder(BaseModel):
    &quot;&quot;&quot;Model for finding the best sequence of tools&quot;&quot;&quot;
    tools_name_in_seq: List[str]

class AgentInfo(BaseModel):
    &quot;&quot;&quot;Model for storing agent information&quot;&quot;&quot;
    name: str
    description: str
    id: str
    tools: List[Dict[str, Any]]
    parameters: Optional[Dict[str, Any]] = None
    embedding: Optional[Any] = None
</code></pre>
<h3>Context-Aware Execution</h3>
<p>The system maintains conversation history throughout tool execution:</p>
<pre><code class="language-python">def gather_tool_inputs(tool_name, tool_function, history, previous_outputs):
    &quot;&quot;&quot;Gather required inputs for tool execution with context&quot;&quot;&quot;
    context_summary = &quot;\n\nPrevious tool outputs: &quot; + str(previous_outputs)
    # Use conversation history and previous outputs to determine inputs
    # ...
</code></pre>
<h2>ğŸ”§ Technology Stack &amp; Dependencies</h2>
<p>The system is built on a modern Python stack:</p>
<pre><code class="language-toml">[project]
dependencies = [
    &quot;openai&gt;=1.78.1&quot;,      # LLM integration
    &quot;pandas&gt;=2.2.3&quot;,       # Data manipulation
    &quot;pydantic&gt;=2.11.4&quot;,    # Type safety
    &quot;pymupdf&gt;=1.25.5&quot;,     # PDF processing
    &quot;numpy&gt;=2.2.5&quot;,        # Numerical computations
    &quot;pyyaml&gt;=6.0.2&quot;,       # Configuration
]
</code></pre>
<h2>ğŸš€ Performance &amp; Scalability Considerations</h2>
<h3>Similarity Threshold Optimization</h3>
<p>The system uses a <strong>0.5 similarity threshold</strong> to balance precision and recall:</p>
<ul>
<li><strong>Above 0.5</strong>: Agent is selected for specialized handling</li>
<li><strong>Below 0.5</strong>: Falls back to general conversation mode</li>
</ul>
<h3>Conversation Context Management</h3>
<p>Smart context preservation without memory overflow:</p>
<pre><code class="language-python"># Store only relevant context for each tool execution
context_summary = &quot;\n\nHistory&quot; + str(history)
</code></pre>
<h3>Parallel Processing Potential</h3>
<p>The architecture supports future enhancements like:</p>
<ul>
<li>ğŸ”„ Concurrent tool execution</li>
<li>ğŸ“Š Batch query processing  </li>
<li>ğŸŒ Distributed agent deployment</li>
</ul>
<h2>ğŸ¨ Configuration-Driven Architecture</h2>
<p>The entire agent ecosystem is defined in <code>agents_behaviour.yaml</code>:</p>
<pre><code class="language-yaml">- name: CSVDataAgent
  description: &quot;Specialized agent for loading, processing, and extracting insights from CSV data&quot;
  tools:
    - name: &quot;DataframeLoader&quot;
      version: &quot;1.2.0&quot;
      input_schema: {&quot;file_path&quot;: &quot;str&quot;}
      output_schema: &quot;pd.DataFrame&quot;
</code></pre>
<p>This allows for:</p>
<ul>
<li>âœ… Easy agent addition/modification</li>
<li>âœ… Version control for tools</li>
<li>âœ… Clear separation of concerns</li>
<li>âœ… Rapid prototyping</li>
</ul>
<h2>ğŸ”® Future Enhancements &amp; Roadmap</h2>
<h3>1. <strong>Advanced Agent Capabilities</strong></h3>
<ul>
<li>ğŸ§® Mathematical computation agents</li>
<li>ğŸ¨ Image processing specialists  </li>
<li>ğŸŒ Web scraping agents</li>
<li>ğŸ“ˆ Real-time data analysis</li>
</ul>
<h3>2. <strong>Enhanced Intelligence</strong></h3>
<ul>
<li>ğŸ¤– Multi-agent collaboration</li>
<li>ğŸ” Self-improving algorithms</li>
<li>ğŸ“Š Performance analytics</li>
<li>ğŸ¯ Adaptive threshold learning</li>
</ul>
<h3>3. <strong>Enterprise Features</strong></h3>
<ul>
<li>ğŸ” Authentication &amp; authorization</li>
<li>ğŸ“Š Usage analytics dashboard</li>
<li>ğŸŒ Multi-tenant support</li>
<li>ğŸ“± API Gateway integration</li>
</ul>
<h2>ğŸš€ Getting Started: Run It Yourself!</h2>
<h3>Quick Setup</h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/rockerritesh/agents.ai.git
cd agents.ai

# Install dependencies
uv sync

# Configure environment
echo &quot;OPENAI_API_KEY=your_key_here&quot; &gt; .env
echo &quot;BASE_URL_OPENAI=https://api.openai.com/v1&quot; &gt;&gt; .env
echo &quot;MODEL_NAME=gpt-4o&quot; &gt;&gt; .env
echo &quot;EMBEDDING_MODEL_NAME=text-embedding-3-large&quot; &gt;&gt; .env

# Run the system
uv run final_version.py
</code></pre>
<h3>Example Interactions</h3>
<pre><code class="language-bash"># CSV Analysis
&quot;Load the small-eq.csv file and show me earthquake patterns&quot;

# Emoji Translation  
&quot;Convert &#39;Happy birthday! ğŸ‰&#39; to pure emojis&quot;

# Content Processing
&quot;Summarize this research paper and expand key findings&quot;
</code></pre>
<h2>ğŸ¯ Key Takeaways for Developers</h2>
<h3>1. <strong>Semantic Understanding is Key</strong></h3>
<p>Using embeddings for agent selection provides much more nuanced understanding than keyword matching.</p>
<h3>2. <strong>Context Preservation Matters</strong></h3>
<p>Maintaining conversation history enables sophisticated multi-turn interactions.</p>
<h3>3. <strong>Type Safety Accelerates Development</strong></h3>
<p>Pydantic models catch errors early and improve code reliability.</p>
<h3>4. <strong>Configuration-Driven Design Scales</strong></h3>
<p>YAML-based agent definitions make the system incredibly extensible.</p>
<h2>ğŸŒŸ Conclusion: The Future is Multi-Agent</h2>
<p>This multi-agent system represents a significant step toward truly intelligent automation. By combining semantic understanding, dynamic tool orchestration, and context-aware processing, we&#39;ve created a system that doesn&#39;t just execute commandsâ€”it thinks about the best way to solve problems.</p>
<p>The implications extend far beyond this implementation:</p>
<ul>
<li>ğŸ¢ <strong>Enterprise Applications</strong>: Automated business process handling</li>
<li>ğŸ“ <strong>Education</strong>: Personalized learning assistants  </li>
<li>ğŸ”¬ <strong>Research</strong>: Intelligent data analysis pipelines</li>
<li>ğŸ  <strong>Consumer Apps</strong>: Smart home automation</li>
</ul>
<hr>
<h3>ğŸ”— Explore Further</h3>
<ul>
<li><strong>ğŸ™ <a href="https://github.com/rockerritesh/agents.ai">GitHub Repository</a></strong> - Dive into the code</li>
<li><strong>ğŸ“– <a href="https://rockerritesh.github.io/agents.ai/">Documentation</a></strong> - Detailed implementation guide</li>
<li><strong>ğŸŒŸ <a href="https://platform.openai.com/docs">OpenAI API Documentation</a></strong> - Understanding the AI foundation</li>
<li><strong>ğŸ“Š <a href="https://pandas.pydata.org/docs/">Pandas Documentation</a></strong> - Data manipulation toolkit</li>
</ul>
<h3>ğŸ’¬ Join the Conversation</h3>
<p>Have questions or ideas for enhancements? Let&#39;s connect and build the future of intelligent automation together!</p>
<p><em>What fascinating applications can you imagine for this multi-agent architecture? The possibilities are endless! ğŸš€</em></p>
<hr>
<p><em>Built with â¤ï¸ using Python, OpenAI GPT-4o, and a vision for intelligent automation</em> </p>

    </div>

    <footer class="post-footer">
        <p><a href="https://tatva.sumityadav.com.np/">&larr; Back to all posts</a></p>
    </footer>
</article> 